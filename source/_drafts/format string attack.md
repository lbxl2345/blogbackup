#### Format String Vulnerability
FSV（格式字符串漏洞）是一类特殊的漏洞，它是由对格式化输出函数（例如C语言中的printf函数家族）的不当使用而造成的。如果攻击者能够控制格式化输出函数的输入，并且应用程序没有进行适当的验证，那么攻击者就能：通过把格式化参数（例如'%x'）插入到数据中，来改变格式化输出函数的行为，让它误认为有更多的参数。而这些参数却并不存在，于是乎攻击者就能够对栈上的数据进行读写了。
#### Capability
格式化输出函数本身并没有漏洞，但FSV给了攻击者控制它们的能力。那么攻击者能够通过FSV做些什么呢？最简单的攻击就是利用FSV让程序崩溃，例如`printf ("%s%s%s%s%s%s%s%s%s%s%s%s");`极有可能读取到没有映射的地址，造成程序崩溃。再者，攻击者也可以通过`%n`来篡改栈上的地址来达到同样的效果。
##### information leakage
如果格式化字符串的输出是可见的（或者间接可见的，例如返回给一个字符串给remote attacker），那么FSV就可能导致信息的泄露。和前面所说的类似，`printf ("%08x.%08x.%08x.%08x.%08x\n");`能够揭露栈上的一部分数据（在64位下揭露的是寄存器和栈中的数据）。但某些情况下，FSV能够被用来揭露任何地址的数据，而不仅仅是栈上的数据。
<!--要做到这一点，攻击者需要具备两个条件：（1）有一个能够用来揭露内存的格式符号，例如"%s"；（2）把要揭露的地址放在栈（或者寄存器）中去。  -->
通常，格式化字符串被放在栈上，而格式化输出函数内部通常会有一个**内部指针**，它指向当前的格式化字符串参数（在64bit下，可变参数会被挪到栈上）。如果能够把目标地址嵌入到格式化字符串当中去，那么目标地址就会被保存在栈上了，这样一来就可以通过操纵**内部指针**的方式，把目标地址的数据给输出。下面这个例子中，`user_input`保存了一个格式化字符串。在32位下，`printf ("\x10\x01\x48\x08 %x %x %x %x %s");`能够揭露0x08480110地址的值。

	int main(int argc, char *argv[])
	{
		char user_input[100];
		... ... /* other variable definitions and statements */
		scanf("%s", user_input); /* getting a string from user */
		printf(user_input); /* Vulnerable place */
		return 0;
	}

<!--如果能够控制这个参数，攻击者就能够通过给"%s"提供一个地址，让它输出这个地址中的数据。一种控制的方式就是通过来修改stack pointer的位置，
例如`printf("AAA0AAA1_%08x.%08x.%08x/%08x");`，-->
##### overwirte memory